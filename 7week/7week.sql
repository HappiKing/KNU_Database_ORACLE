-- 13-1) SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기(DICT)
SELECT * FROM DICT;

-- 13-2) SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기(DICTIONARY 사용)
SELECT * FROM DICTIONARY;

-- 13-3) SCOTT 계정이 가지고 있는 객체 정보 살펴보기(USER_ 접두어 사용)
SELECT TABLE_NAME FROM USER_TABLES;

-- 13-4) SCOTT 계정이 사용할 수 있는 객체 정보 살펴보기(ALL_ 접두어 사용)
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

-- 13-5) SCOTT 계정으로 DBA_ 접두어 사용하기
SELECT * FROM DBA_TABLES;

-- 13-6) SYSTEM 계정으로 DBA_접두어 사용하기 (SYSTEM 계정으로 접속했을 때)
SELECT * FROM DBA_TABLES;

-- 13-7) DBA_USERS를 사용하여 사용자 정보를 알아보기(SYSTEM 계정으로 접속했을 때)
SELECT * FROM DBA_USERS WHERE USERNAME = 'SCOTT';

-- 13-8) SCOTT 계정이 소유한 인덱스 정보 알아보기(SCOTT 계정일 때)
SELECT * FROM USER_INDEXES;

-- 13-9) SCOTT 계정이 소유한 인덱스 컬럼 정보 알아보기(SCOTT 계정일 때)
SELECT * FROM USER_IND_COLUMNS;

-- 13-10) EMP 테이블의 SAL 열에 인덱스를 생성하기
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

-- 13-11) 생성된 인덱스 살펴보기(SUER_IND_COLUMNS 사용)
SELECT * FROM USER_IND_COLUMNS;

-- 13-12) 인덱스 삭제하기
DROP INDEX IDX_EMP_SAL;

-- 13-13) 생성된 인덱스 살펴보기(SUER_IND_COLUMNS 사용)
SELECT * FROM USER_IND_COLUMNS;

-- 13-14) 뷰를 생성하기 위해 계정 변경 접속하기
SQLPLUS SYSTMEM/oracle

GRANT CREAETE VIEW TO SCOTT;

-- 13-15) 뷰 생성하기
CREATE VIEW VW_EMP20 AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);

-- 13-16) 생성한 뷰 확인하기
SELECT * FROM USER_VIEWS;

-- 13-17) 생성한 뷰 내용 확인하기(SCOTT 계정으로 접속했을 때)
SELECT VIEW_NAME, TEXT_LENGTH, TEXT FROM USER_VIEWS;

-- 13-18) 생성한 뷰 조회하기
SELECT * FROM VW_EMP20;

-- 13-19) 뷰 삭제하기
DROP VIEW VW_EMP20;

-- 13-20) ROWNUM을 추가로 조회하기
SELECT ROWNUM, E.* FROM EMP E;

-- 13-21) EMP 테이블을 SAL 열 기준으로 정렬하기
SELECT ROWNUM, E.* FROM EMP E ORDER BY SAL DESC;

-- 13-22) 인라인 뷰(서브쿼리 사용)
SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E;

-- 13-23) 인라인 뷰(WITH절 사용)
WITH E AS(SELECT * FROm EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E;

-- 13-24) 인라인 뷰로 TOP-N 추출하기 (서브쿼리 사용)
SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E WHERE ROWNUM <= 3;

-- 13-25) 인라인 뷰로 TOP-N 추출하기(WITH 절 사용)
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E WHERE ROWNUM <= 3;

-- 13-26) DEPT 테이블을 사용하여 DEPT_SEQUENCE 테이블 생성하기
CREATE TABLE DEPT_SEQUENCE AS SELECT * FROM DEPT WHERE 1<>1 ;

SELECT * FROM DEPT_SEQUENCE;

-- 13-27) 시퀸스 생성하기
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
START WITH 10
MAXVALUE 90
MINVALUE 0
NOCYCLE
CACHE 2;

-- 13-28) 생성한 시퀸스 확인하기
SELECT * FROM USER_SEQUENCES;

-- 13-29) 시퀸스에서 생성한 순번을 사용한 INSERT 문 실행하기
INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

-- 13-30) 가장 마지막으로 생성된 시퀸스 확인하기
SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

-- 13-31) 시퀸스에서 생성한 순번을 반복 사용하여 INSERT문 실행하기
INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

-- 13-32) 시퀸스 옵션 수정하기
ALTER SEQUENCE SEQ_DEPT_SEQUENCE INCREMENT BY 3 MAXVALUE 99 CYCLE;

-- 13-33) 옵션을 수정한 시퀸스 조회하기
SELECT * FROM USER_SEQUENCES;

-- 13-34) 수정한 시퀸스를 사용하여 INSERT문 실행하기 
INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

-- 13-35) CYCLE 옵션을 사용한 시퀸스의 최댓값 도달 후 수행 결과 확인하기
INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

-- 13-36) 시퀸스 삭제 후 확인하기
DROP SEQUENCE SEQ_DEPT_SEQUENCE;

SELECT * FROM USER_SEQUENCES;

-- 13-37) 권한 부여하기(SQL * PLUS)
SQLPLUS SYSTEM/oracle

GRANT CREAT SYNONYM TO SCOTT;

GRANT CREATE PUBLIC SYNONYM TO SCOTT;

-- 13-38) EMP 테이블의 동의어 생성하기
CREATE SYNONYM E FOR EMP;

-- 13-39) E 테이블 전체 내용 조회하기
SELECT * FROM E;

-- 13-40) 동의어 삭제하기
DROP SYNONYM E;

----------------------------------------------------------------------------------
-- 14-1) 테이블을 생성할 때 NOT NULL 설정하기
CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
    );
    
    DESC TABLE_NOTNULL;
 
-- 14-2) 제약 조건이 NOT NULL인 열에 NULL 값 넣어보기
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', NULL, '010-1234-5678');

-- 14-3) 제약 조건이 없는 TEL 열에 NULL 값 입력하기 
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD)
VALUES ('TEST_ID_01', '1234');

SELECT * FROM TABLE_NOTNULL;

-- 14-4) NOT NULL 제약 조건이 지정된 열 데이터를 NULL 값으로 업데이트하기
UPDATE TABLE_NOTNULL SET LOGIN_PWD = NULL WHERE LOGIN_ID = 'TEST_ID_01';

-- 14-5) 제약 조건 살펴보기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

-- 14-6) 테이블을 생성할 때 제약 조건에 이름 지정하기
CREATE TABLE TABLE_NOTNULL2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
    TEL VARCHAR2(20)
    );
    
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

-- 14-7) TEL 열에 NOT NULL 제약 조건 추가하기
ALTER TABLE TABLE_NO기TNULL MODIFY(TEL NOT NULL);

-- 14-8) TEL 열 데이터 수정하기
UPDATE TABLE_NOTNULL SET TEL = '010-1234-5678' WHERE LOGIN_ID = 'TEST_ID_01';

SELECT * FROM TABLE_NOTNULL;

-- 14-9) NOT NULL 제약 조건 추가하기 
ALTER TABLE TABLE_NOTNULL MODIFY(TEL NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

-- 14-10) 제약 조건에 이름 지정해서 추가하기
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

-- 14-11) TABLE_NOTNULL2 테이블 열 구조 확인하기
DESC TABLE_NOTNULL2;

-- 14-12) 이미 생성된 제약 조건 이름 변경하기
ALTER TABLE TABLE_NOTNULl2 RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

-- 14-13) 제약 조건 삭제하기
ALTER TABLE TABLE_NOTNULL2 DROP CONSTRAINT TBLNN2_TEL_NN;

DESC TABLE_NOTNULL2;

-- 14-14)제약 조건 지정하기(테이블을 생성할 때
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR2(20) UNIQUE,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
    );
    
DESC TABLE_UNIQUE;

-- 14-15) USER_CONSTRAINTS 데이터 사전 뷰로 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_UNIQUE';

-- 14-16) TABLE_UNIQUE 테이블에 데이터 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

SELECT * FROM TABLE_UNIQUE;

-- 14-17) LOGIN_ID 열에 중복되는 데이터 넣기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

-- 14-18) TABLE_UNIQUE 테이블에 데이터 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_02', 'PWD01', '010-2345-6789');

SELECT * FROM TABLE_UNIQUE;

-- 14-19) UNIQUE 제약 조건이 지정된 열에 NULL 값 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, 'PWD01', '010-2345-6789');

SELECT * FROM TABLE_UNIQUE;

-- 14-20) TABLE_UNIQUE 테이블 데이터 수정하기
UPDATE TABLE_UNIQUE SET LOGIN_ID='TEST_ID_01' WHERE LOGIN_ID IS NULL;

-- 14-21) 테이블을 생성할 때 UNIQUE 제약 조건 설정하기
CREATE TABLE TABLE_UNIQUE2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNQ2_LOGIN_UNQ UNIQUE,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL,
    TEL VARCHAR2(20)
    );

-- 14-22) 생성한 UNIQUE 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

-- 14-23) 이미 생성한 테이블 열에 UNIQUE 제약 조건 추가
ALTER TABLE TABLE_UNIQUE MODIFY(TEL UNIQUE);

-- 14-24) TEL 열 값을 모두 NULl 값으로 변경하기
UPDATE TABLE_UNIQUE SET TEL = NULL;
SELECT * FROM TABLE_UNIQUE;

-- 14-25) TEL 값에 UNIQUE 제약 조건 설정하기
ALTER TABLE TABLE_UNIQUE MODIFY(TEL UNIQUE);

-- 14-26) UNIQUE 제약 조건 이름 직접 지정하기
ALTER TABLE TABLE_UNIQUE2 MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

-- 14-27) 이미 만들어져 있는 UNIQUE 제약 조건 이름 수정하기
ALTER TABLE TABLE_UNIQUE2 RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

-- 14-28) 제약 조건 삭제하기
ALTER TABLE TABLE_UNIQUE2 DROP CONSTRAINT TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

-- 14-29) 테이블을 생성할 때 특정 열에 PRIMARY KEY 설정하기
CREATE TABLE TABLE_PK(
    LOGIN_ID VARCHAR2(20) PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
    );
    
DESC TABLE_PK;

-- 14-30) 생성한 PRIMARY KEY 확인하기
SELECT OWNER, CONSTR기AINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_PK%';


-- 14-31) 생성한 PRIMARY KEY를 통해 자동 생성된 INDEX 확인하기
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME LIKE 'TABLE_PK%';


-- 14-32) 제약 조건의 이름을 직접 지정하여 테이블 생성하기
CREATE TABLE TABLE_PK2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLPK2_LOGIN_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR(20) CONSTRAINT TBLPK2_LOGPW_NN NOT NULL,
    TEL VARCHAR(20)
    );

DESC TABLE_PK2;

-- 14-33) TABLE_PK 테이블에 데이터 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

SELECT * FROM TABLE_PK;

-- 14-34) TABLE_PK 테이블에 중복되는 데이터 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_01', 'PWD02', '010-2345-6789');

-- 14-35) NULL 값을 명시적으로 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, 'PWD02', '010-2345-6789');

-- 14-36) NULL 값을 암시적으로 입력하기
INSERT INTO TABLE_PK(LOGIN_PWD, TEL) VALUES('PWD02', '010-2345-6789');

-- 14-37) EMP 테이블과 DEPT 테이블의 제약 조건 알아보기 
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME R_OWNER, R_CONSTRAINT_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME IN ('EMP', 'DEPT');

-- 14-38) FOREIGN KEY가 참조하는 열에 존재하지 않는 데이터 입력하기
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동', 'CLERK', '7788', To_DATE('2017/04/30', YYYY/MM/DD), 1200, NULL, 30);

-- 14-39) DEPT_FK 테이블 생성하기
CREATE TABLE DEPT_FK(
    DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(20)
);

DESC DEPT_FK;

-- 14-40) EMP_FK 테이블 생성하기
CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7,2),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) CONSTRAINT EMPKF_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO)
    );

DESC EMP_FK;

-- 14-41) EMP_FK 테이블에 데이터 삽입하기(DEPTNO 데이터가 아직 DEPT_FK 테이블에 없을 때)
INSERT INTO EMP_FK VALUES(9999, 'TEST_ENAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000, NULL, 10); 

-- 14-42) DEPT_FK에 데이터 삽입하기
INSERT INTO DEPT_FK VALUES(10, 'TEST_DNAME', 'TEST_LOC');

SELECT * FROM DEPT_FK;

-- 14-43) EMP_FK 테이블에 데이터 삽입하기
INSERT INTO EMP_FK VALUES(9999, 'TEST_ENAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000, NULL, 10); 

SELECT * FROM EMP_FK;

-- 14-44) DEPT_FK 테이블의 10번 부서 데이터 삭제하기
DELETE FROM DEPT_FK WHERE DEPTNO = 10;

-- 14-45) 테이블을 생성할 때 CHECK 제약 조건 설정하기
CREATE TABLE TABLE_CHECK(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK(LENGTH(LOGIN_PWD) > 3),
    TEL VARCHAR2(20)
    );

DESC TABLE_CHECK;

-- 14-46) CHECK 제약 조건에 맞지 않는 예
INSERT INTO TABLE_CHECK VALUES('TEST_ID', '123', '010-1234-5678');

-- 14-47) CHECK 제약 조건에 맞는 예
INSERT INTO TABLE_CHECK VALUES('TEST_ID', '1234', '010-1234-5678');

SELECT * FROM TABLE_CHECK;

-- 14-48) CHECK 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_CHECK';

-- 14-49) 테이블을 생성할 때 DEFAULT 제약 조건 설정하기
CREATE TABLE TABLE_DEFAULT(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) DEFAULT '1234',
    TEL VARCHAR2(20)
    );
    
DESC TABLE_DEFAULT;
    
-- 14-50) DEFAULT로 지정한 기본값이 입력되는 INSERT 문 확인하기 
INSERT INTO TABLE_DEFAULT VALUES ('TEST_ID', NULL, '010-1234-5678');
INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES ('TEST_ID2', '010-1234-5678');
SELECT * FROM TABLE_DEFAULT;

---------------------------------

-- 15-1) SCOTT 계정으로 사용자 생성하기
CREATE USER ORCLSTUDY IDENTIFIED BY ORACLE;

-- 15-2) SYSTEM 사용자로 접속 후 사용자 생성하기
CREATE USER ORCLSTUDY IDENTIFIED BY ORACLE;

-- 15-3) SYSTEM 사용자로 접속 후 ORCLSTUDY 사용자에게 권한 부여하기
GRANT CREATE SESSION TO ORCLSTUDY;

-- 15-4) 사용자 정보(패스워드) 변경하기
ALTER USER ORCLSTUDY IDENTIFIED BY ORCL;

-- 15-5) 사용자 삭제하기
DROP USER ORCLSTUDY;

-- 15-6) 사용자와 객체 모두 삭제하기
DROP USER ORCLSTUDY CASCADE;

-- 15-7) SYSTEM 계정으로 접속하여 사용자 생성하기
CREATE USER ORCLSTUDY IDENTIFIED BY ORACLE;

-- 15-8) 사용자 권한 부여하기
GRANT RESOURCE, CREATE SESSION, CREATE TABLE TO ORCLSTUDY;

-- 15-9) ORCLSTUDY 사용자에게 TEMP 테이블 권한 부여하기
CONN SCOTT/Tiger

CREATE TABLE TEMP(
    COL1 VARCHAR2(20),
    COL2 VARCHAR2(20)
    );
    
GRANT SELECT ON TEMP TO ORCLSTUDY;
GRANT INSERT ON TEMP TO ORCLSTUDY;

-- 15-10) ORCL에게 TEMP 테이블의 여러 권한을 한번에 부여하기
GRANT SELECT, INSERT ON TEMP TO ORCLSTUDY;

-- 15-11) ORCLSTUDY로 사용 권한을 부여받은 TEMP 테이블 사용하기
CONN ORCLSTUDY/ORACLE

SELECT * FROM SCOTT.TEMP;

INSERT INTO SCOTT.TEMP VALUES ('TEXT', 'FROM ORCLSTUDY');

SELECT * FROM SCOTT.TEMP;

-- 15-12) ORCLSTUDY에 부여된 TEMP 테이블 사용 권한 취소하기
CONN SCOTT/tiger

REVOKE SELECT, INSERT ON TEMP FROM ORCLSTUDY;

-- 15-13) ORCLSTUDY로 권한 철회된 TEMP 테이블 조회하기(실패)
CONN ORCLSTUDY/ORACLE
SELECT * FROM SCOTT.TEMP;

-- 15-14) SYSTEM 계정으로 ROLESTUDY 롤 생성 및 권한 부여하기
CONN system/pass

CREATE ROLE ROLESTUDY;

GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE SYNONYM TO ROLESTUDY;

-- 15-15) ORCLSTUDY 사용자에게 롤(ROLESTUDY) 부여하기
GRANT ROLESTUDY TO ORCLSTUDY;

-- 15-16) CONN ORCLSTUDY에 부여된 롤과 권한 확인하기
CONN ORCLSTUDY/ORACLE
SELECT * FROM USER_SYS_PRIVS;
SELECT * FROM USER_ROLE_PRIVS;